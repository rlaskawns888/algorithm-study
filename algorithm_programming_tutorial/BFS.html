<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            너비 우선 탐색(BFS)

            - Breadth First Search, BFS
            - '맹목적인 탐색'을 하고자 할 떄 사용할 수 있는 탐색 기법
            - 너비 우선 탐색은 '탐색 경로'를 찾아준다는 점에서 최단 길이를 보장해야 할 때 많이 사용됨            
        */

        //정점 개수
        const n = 7; 
        
        //간선 정보
        const edges = [
            [1, 2], [1, 3],
            [2, 4], [2, 5],
            [3, 6], [3, 7]
        ];
        
        const graph = Array.from({ length: n + 1 }, () => []);
        for (const [a, b] of edges) {
            graph[a].push(b);
            graph[b].push(a);
        }
        console.log('graph: ', graph);
        /*
            graph 배열을 생성하고 edges 정보를 기반으로 인접 리스트 방식의 그래프를 생성.

            graph:  [ [], [], [], [], [], [], [], [] ]
            graph:  [ [], [ 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 2 ], [ 2 ], [ 3 ], [ 3 ] ]

        */
        const visited = Array.from({length: n + 1}, () => false);
        const queue = [];
        let answer = "";
        
        queue.push(1);
        visited[1] = true;

        // console.log('visited: ', visited);
        // console.log('queue: ', queue);

        while(queue.length > 0) {
            const v = queue.shift();
            answer += `${v}`;

            console.log('answer: ', answer);

            for(const nv of graph[v]) {                
                if(!visited[nv]) {
                    visited[nv] = true;
                    queue.push(nv);

                    console.log('queue: ', queue);
                }
            }
        }

        console.log(answer);


    </script>
</body>
</html>
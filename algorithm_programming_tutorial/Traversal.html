<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            [기본적으로 가장 많이 사용되는 비선형 자료구조]
            - 이진 트리(Binary Tree)


            [이진트리]
            - 트리 자료구조를 활용한 대표적인 예시로 데이터의 탐색 속도 증민을 위해 사용하는 구조.
            - 실제로 트리를 제대로 구현하기 위해서는 포인터(Pointer)를 사용해야한다.
            (포인터를 이용해 루트에서 자식노드로 접근 가능하다)


            [데이터를 탐색하는 방법]
            1. 전위 순회(Preorder Traversal)
             - 먼저 자기 자신을 처리.
             - 왼쪽 자식 방문
             - 오른쪽 자식 방문

            2. 중위 순회(Inorder Traversal)            
            - 왼쪽 자식 방문
            - 먼저 자기 자신 처리
            - 오른쪽 자식 방문

            3. 후위 순회(Postorder Travelsal)
            - 왼쪽 자식 방문
            - 오른쪽 자식 방문
            - 자기 자신 처리
        */

        class Node {
            constructor(data, left=null, right=null) {
                this.data = data;
                this.left = left;
                this.right = right;
            }
        }
        
        class BinaryTree {
            constructor() {
                this.root = null;
            }

            //이진 트리에 노드를 추가하는 메서드
            addNode(data) {
                const node = new Node(data);

                if(!this.root) {
                    this.root = node;
                    return;
                }

                let current = this.root;

                while(true) {
                    if(data < current.data) {
                        if(!current.left) {
                            current.left = node;
                            return;
                        }
                        current = current.left;
                    } else {
                        if(!current.right) {
                            current.right = node;
                            return;
                        }
                        current = current.right;
                    }
                }
            }

            //전위 순회 함수
            preorderTraversal(node) {
                if(!node) return;

                console.log(node.data);
                this.preorderTraversal(node.left);
                this.preorderTraversal(node.right);
            }

            //중위 순회 함수
            inorderTraversal(node) {
                if(!node) return;

                this.inorderTraversal(node.left);
                console.log(node.data);
                this.inorderTraversal(node.right);
            }

            //후위 순회 함수
            postorderTraversal(node) {
                if(!node) return;

                this.postorderTraversal(node.left);
                this.postorderTraversal(node.right);
                console.log(node.data);
            }

        }

        // 예제 코드
        const tree = new BinaryTree();

        tree.addNode(8);
        tree.addNode(3);
        tree.addNode(10);
        tree.addNode(1);
        tree.addNode(6);
        tree.addNode(14);
        tree.addNode(4);
        tree.addNode(7);
        tree.addNode(13);

        console.log(tree);
        //     8
        //    /   \
        //   3    10
        //  / \     \
        // 1   6    14
        //    / \
        //   4   7
        //        \
        //         13

        console.log("Preorder Traversal:");
        tree.preorderTraversal(tree.root);

        console.log("Inorder Traversal:");
        tree.inorderTraversal(tree.root);

        console.log("Postorder Traversal:");
        tree.postorderTraversal(tree.root);
    </script>
</body>
</html>
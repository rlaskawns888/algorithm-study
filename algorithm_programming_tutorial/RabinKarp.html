<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabin Karp</title>
</head>
<body>
    <script>
        /*
            라빈 카프 Rabin Karp

            - 특이한 문자열 매칭 알고리즘
            - 항상 빠르지는 않지만 일반적인 경우 빠르게 동작하는 간단한 구조의 문자열 매칭 알고리즘
            - Hash 기법
            - 해시는 일반적으로 긴 데이터를 그것을 상징하는 짧은 데이터로 바꿔주는 기법
            상징하는 데이터로 바꾸어 처리한다는 점에서 단순 해시 알고리즘의 경우 연산 속도가 O(1) 라는 장점이 있음

            
            abacaabb

            = 97 * 2 ^ 7 +
              98 * 2 ^ 6 +
              97 * 2 ^ 5 +
              99 * 2 ^ 4 +
              97 * 2 ^ 3 +
              97 * 2 ^ 2 +
              98 * 2 ^ 1 + 
              98 * 2 ^ 0 
            = 24,834


            [2를 곱해주는 이유]
            : 문자열이 달라지면, 문자열에 해당하는 결과로 출력되는 해시의 값이 출력된다는것을 볼수 있다.
            다른 문자열이라도 결과로 출룍되는 해시의 값이 같을수 있는데 이것을 충돌(Collision)이라고 부른다.
            이러한 충돌을 방지하기위해서 2를 곱해주는것이다.

            [해시]
            : : https://velog.io/@hanif/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C



            -> 여러개의 문자열을 비교할 때 항상 해시 값을 구하여 비교하고, 해시 값은 거의 일치하는 일이 없기 때문에
            긴 글과 부분 문자열의 해시 값이 일치하는 경우에만 문자열을 재검사하여 정확히 일치하는지 확인하는 알고리즘.

            *** 긴 글 해시값 = 2 * (긴 글 해시값 - 가장 앞에 있는 문자의 수치) + 새롭게 들어온 문자의 수치 *** 
            
        */
        
        let parent = 'ababacabacaabacaaba';
        let pattern = 'abacaaba';
        findString(parent, pattern);

       
        function findString(parent, pattern) {
            let parentLen = parent.length;
            let patternLen = pattern.length;
            let parentHash = 0;
            let patternHash = 0;
            let power = 1;
            
            for(let i = 0; i <= parentLen - patternLen; i++) {
                if(i == 0) {
                    for(let j = 0; j < patternLen; j++) {
                        //긴 글 해시값 = 2 * (긴 글 해시값 - 가장 앞에 있는 문자의 수치) + 새롭게 들어온 문자의 수치

                        parentHash = parentHash + parent[patternLen - 1 - j].charCodeAt() * power;
                        patternHash = patternHash + pattern[patternLen - 1 - j].charCodeAt() * power;
                        
                        console.log('parentHash: ', parentHash);
                        console.log('patternHash: ', patternHash);
                        
                    }
                }
            }
        }

    </script>
</body>
</html>